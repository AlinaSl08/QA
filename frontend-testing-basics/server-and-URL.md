# Клиент-серверная архитектура
## Сервер

**Сервер в клиент-серверной архитектуре** – это часть системы, которая принимает запросы от клиента, обрабатывает их и возвращает ответ. Сервер отвечает за логику работы приложения и работу с данными.

**Основные функции сервера**:

1. приёма клиентских запросов;
2. обработки запросов согласно бизнес‑логике;
3. доступа к данным (Базе данных, файлам, внешним сервисам);
4. формирования и отправки ответов клиенту.
 

У сервера может быть **Монолитная** или **Микросервисная** архитектура: 

**Монолит** – это когда вся серверная логика приложения собрана в одном большом приложении.

+ Один кодовый проект;
+ Все модули (авторизация, заказы, каталог, оплата) живут в одном процессе;
+ Разворачивается и обновляется как единое целое.
 

**Микросервисы** – это когда логика приложения разделена на набор небольших независимых сервисов, каждый отвечает за свою область.

Примеры сервисов:

+ сервис пользователей
+ сервис заказов
+ сервис каталога товаров
 сервис оплаты
 

Для тестировщика это важно, потому что **от архитектуры сервера зависит, как именно мы будем тестировать.**

1) Если **монолит**, то у нас один сервер.
Мы проверяем:

+ бизнес-логику в одном приложении,
+ его API,
+ работу с одной общей базой данных.

2) Если **микросервисы**, то кроме проверки каждого сервиса **по отдельности**, нужно ещё смотреть:

+ как сервисы общаются друг с другом;
+ не теряются ли данные между ними;
+ что происходит, если один сервис задерживается или временно недоступен.

Проще говоря:
при монолите мы тестируем **"один большой сервер"**,
при микросервисах – **много маленьких серверов и их взаимодействие друг с другом**.

---
## Клиент

**Клиент** – это визуальная и интерактивная часть приложения, с которой взаимодействует пользователь.

**Основные функции клиента**:

1. **Формирование запросов** – подготовка и отправка запросов к серверу.
2. **Обработка ответов** – получение и интерпретация данных от сервера.
3. **Отображение информации** – визуализация полученных данных для пользователя.
4. **Валидация ввода** – проверка корректности данных перед отправкой на сервер.
5. **Управление состоянием** – хранение локальных данных (например, сессии, настройки).
6. **Обеспечение интерфейса** – предоставление удобного способа взаимодействия с системой.
 
**Виды клиентов**:
**1. Толстый клиент** (fat client):

+ Большая часть логики выполняется на стороне клиента.
+ Требует установки на устройство.
+ Работает автономно (частично).
+ Примеры: десктопные приложения (Microsoft Office, Photoshop).

**2. Тонкий клиент** (thin client):

+ Минимальные вычислительные ресурсы на стороне клиента.
+ Основная логика на сервере.
+ Не требует установки (часто веб‑интерфейс).
+ Примеры: Веб‑браузер (Chrome, Firefox), Онлайн‑банкинг (веб‑версия).

**3. Гибридный клиент** (hybrid client):

+ Сочетает черты толстого и тонкого клиента.
+ Часть логики на клиенте, часть на сервере.
+ Может работать офлайн с последующей синхронизацией.
+ Примеры: ВКонтакте, 2ГИС.
 

**Взаимодействие клиента с сервером происходит следующим образом**:  

1. Клиент формирует запрос;
2. Отправляет его на сервер;
3. Сервер обрабатывает запрос;
4. Клиент получает ответ и отображает результат.

# URL

**URL (Uniform Resource Locator)** – это адрес ресурса в интернете.

**Стандартный URL включает несколько частей**:
```
scheme://domain:port/path?query#fragment
```
                  
 

1. **Схема (protocol)**

Определяет, как клиент будет обращаться к серверу.

Наиболее важные:

|Протокол|	Назначение|
|:--:|:--:|
|`http://`|	стандартный протокол, передающий данные в открытом виде|
|`https://`|	безопасная версия HTTP, которая шифрует данные|

Пример:

**https**://example.com


2. **Домен (domain, hostname)**

Это адрес сервера, на котором расположен ресурс.

Примеры:

+ `vk.com`
+ `api.shop.ru`
+ `localhost` (локальная машина)
 

3. **Порт (port)**

Это числовой идентификатор на сервере, через который клиент устанавливает соединение.

Стандартные порты:

+ 80 для HTTP
+ 443 для HTTPS

Обычно порт скрыт, но если нестандартный – он прописывается в URL после хоста через двоеточие: 

Пример:

http://localhost:8080

 

4. **Параметр пути (path parameters)**

Определяет, какой ресурс запрашивается на сервере.

Примеры:

+ `/products`
+ `/api/users/45`
+ `/v1/orders/create`

Пример:

https://example.com/api/products

 

5. **Параметры запроса (query parameters)**

Добавляют дополнительные данные к запросу. Записываются после `?`, несколько параметров разделяются `&`.

Пример:

+ `?page=2&sort=asc`

Пример URL с query parameters:

https://example.com/api/products**?page=2&sort=asc**

 

6. **Фрагмент (fragment / anchor)**

Часть после `#`, используется только на стороне клиента, не передаётся на сервер. Указывает на конкретный раздел внутри страницы.

Пример:

https://example.com/docs#section2

Фрагмент используется браузером, а сервер про него ничего не знает.

**Пример работы фрагмента**:

1. Пользователь переходит по URL с фрагментом (например, `https://site.com/page#section3`).
2. Браузер запрашивает у сервера страницу `https://site.com/page` (без фрагмента).
3. После загрузки страницы браузер находит элемент с соответствующим ID и прокручивает к нему.

**Примеры использования**:

1. **Навигация по длинной статье**:
`https://example.com/guide#installation` – переход к разделу "Установка"

2. **Ссылки на комментарии**:
`https://blog.com/post#comment-123` – переход к конкретному комментарию

3. **Раздел отзывы**:
`https://shop.com/product#reviews` – открытие вкладки "Отзывы"

 

**Пример полного разбора URL**

Возьмём URL:

`https://shop.example.com:443/api/products/list?page=3&sort=price#reviews`

                  
Разбор:

|Часть|	Значение|
|:--:|:--:|
|Scheme|	`https`|
|Domain|	`shop.example.com`|
|Port	|`443`|
|Path|	`/api/products/list`|
|Query|	`page=3&sort=price`|
|Fragment|	`reviews`|

---
